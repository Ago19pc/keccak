
//576 SHA3512
//832 SHA3384
//1024 ??
//1088 SHAKE256, SHA3256
//1152 SHA3224
//1344 SHAKE128
//1600 ??



#include <stdint.h>
#include <immintrin.h>
#include <stdlib.h>

typedef struct keccak_state_t {
    __m256i a0, a1, a2, a3, a4, c4, a44;
} keccak_state_t;




#define XOR(a, b) _mm256_xor_si256(a, b)
#define SET(i0, i1, i2, i3) _mm256_setr_epi64x(i0, i1, i2, i3)
#define MASKLOAD(p, i0, i1, i2, i3) _mm256_maskload_epi64((const int64_t*) p, SET((uint64_t) (i0)  << 63, (uint64_t) (i1) << 63, (uint64_t) (i2) << 63, (uint64_t) (i3) << 63))

#define CONSTANTS \
__m256i SLLVA0 = _mm256_setr_epi64x(0,  1, 62, 28);\
__m256i SRLVA0 = _mm256_setr_epi64x(64, 63, 2, 36);\
__m256i SLLVA2 = _mm256_setr_epi64x(3,  10, 43, 25);\
__m256i SRLVA2 = _mm256_setr_epi64x(61, 54, 21, 39);\
__m256i SLLVA1 = _mm256_setr_epi64x(36,  44, 6, 55);\
__m256i SRLVA1 = _mm256_setr_epi64x(28, 20, 58, 9);\
__m256i SLLVA3 = _mm256_setr_epi64x(41,  45, 15, 21);\
__m256i SRLVA3 = _mm256_setr_epi64x(23, 19, 49, 43);\
__m256i SLLVA4 = _mm256_setr_epi64x(18,  2, 61, 56);\
__m256i SRLVA4 = _mm256_setr_epi64x(46, 62, 3, 8);\
__m256i SLLVC4 = _mm256_setr_epi64x(27,  20, 39, 8);\
__m256i SRLVC4 = _mm256_setr_epi64x(37, 44, 25, 56);\
\
__m256i SLLV_A0 = _mm256_setr_epi64x(0,  1, 62, 28);\
__m256i SLLV_A0 = _mm256_setr_epi64x(0,  1, 62, 28);\
__m256i SLLV_A0 = _mm256_setr_epi64x(0,  1, 62, 28);\
__m256i SRLV_A0 = _mm256_setr_epi64x(64, 63, 2, 36);\
__m256i SLLV_A2 = _mm256_setr_epi64x(3,  10, 43, 25);\
__m256i SRLV_A2 = _mm256_setr_epi64x(61, 54, 21, 39);\
__m256i SLLV_A1 = _mm256_setr_epi64x(36,  44, 6, 55);\
__m256i SRLV_A1 = _mm256_setr_epi64x(28, 20, 58, 9);\
__m256i SLLV_A3 = _mm256_setr_epi64x(41,  45, 15, 21);\
__m256i SRLV_A3 = _mm256_setr_epi64x(23, 19, 49, 43);\
__m256i SLLV_A4 = _mm256_setr_epi64x(18,  2, 61, 56);\
__m256i SRLV_A4 = _mm256_setr_epi64x(46, 62, 3, 8);\
__m256i SLLV_C4 = _mm256_setr_epi64x(27,  20, 39, 8);\
__m256i SRLV_C4 = _mm256_setr_epi64x(37, 44, 25, 56);\
__m256i SRLV_C4 = _mm256_setr_epi64x(37, 44, 25, 56);\
__m256i SRLV_C4 = _mm256_setr_epi64x(37, 44, 25, 56);

#define PERMUTE_VARS\
    __m256i a0, a1, a2, a3, a4, c4;\
    __m256i a04, a14, a24, a34, a44;\
    __m256i b0, b1, b2, b3, b4;\
    __m256i b04, b14, b24, b34, b44;\
    __m256i r0, r1, r2, r3;\
    keccak_state_t* s = (keccak_state_t*) state;\
    ptrdiff_t iterator;


#define LOAD(p)\
    _mm256_loadu_si256((__m256i*) p)

#define STORE(p, a)\
    _mm256_storeu_si256((__m256i*) p, a)


#define STATE_LOAD\
    a0 = LOAD(&(s->a0));\
    a1 = LOAD(&(s->a1));\
    a2 = LOAD(&(s->a2));\
    a3 = LOAD(&(s->a3));\
    a4 = LOAD(&(s->a4));\
    c4 = LOAD(&(s->c4));\
    a44 = LOAD(&(s->a44));

#define STATE_STORE\
    STORE(&s->a0, a0);\
    STORE(&s->a1, a1);\
    STORE(&s->a2, a2);\
    STORE(&s->a3, a3);\
    STORE(&s->a4, a4);\
    STORE(&s->c4, c4);\
    STORE(&s->a44, a44);


#define MMSHUFFLE() ;
#define PERMUTE(a, i0, i1, i2 ,i3) ;


#define PERMUTE_LOOP(const_pref, nofRounds)  

#define STATE_PERMUTE(const_pref) \
    PERMUTE_LOOP(const_pref, 24);\




void extractBytes(const void* state, uint8_t* data, size_t offset, size_t length) {
    keccak_state_t* s = (keccak_state_t*) state;
    uint64_t state_vec[25];
    uint64_t *data64 = (!offset && (length >= 200)) ? (uint64_t*) data : state_vec;
    uint64_t* c4 = (uint64_t*) (&s->c4);
    if  (data64 == state_vec && length > 200){
        length = 200;
    }
    STORE(data64, s->a0);
    STORE(data64 + 5, s->a1);
    STORE(data64 + 10, s->a2);
    STORE(data64 + 15, s->a3);
    STORE(data64 + 20, s->a4);
    data64[4] = c4[0];
    data64[9] = c4[1];
    data64[14] = c4[2];
    data64[19] = c4[3];
    data64[24] = c4[4];

    if (data64 == state_vec)
    {
        memcpy(data, (uint8_t*) state_vec + offset, length);
    }

}



void addBytes(void *state, const uint8_t* data, size_t offsetof, size_t length){
    keccak_state_t* s = (keccak_state_t*) state;
    uint64_t* data64 = (uint64_t*) data;
    uint8_t * currentStateBytePosition, *currentDataBytePosition;
    uint64_t state_vec[25];
    uint64_t* base_state_byte_position;
    ptrdiff_t currentWindow = length / 8;
    ptrdiff_t currentByte = length % 8;
    ptrdiff_t i;
    extractBytes(state, (uint8_t*) state_vec, 0, 200);

    base_state_byte_position = (uint64_t*) ((uint8_t*) state_vec + offsetof);
    for (i = 0; i < currentWindow; i++) {
        base_state_byte_position[i] ^= data64[i];
    }

    if (currentByte) {
        currentStateBytePosition = (uint8_t*) (base_state_byte_position+i);
        currentDataBytePosition = (uint8_t*) (data64 + i);
        for (i = 0; i < currentByte; i++){
            currentStateBytePosition[i] ^= currentDataBytePosition[i];
        }
    }

    s->a0 = LOAD(state_vec);
    s->a1 = LOAD(state_vec + 5);
    s->a2 = LOAD(state_vec + 10);
    s->a3 = LOAD(state_vec + 15);
    s->a4 = LOAD(state_vec + 20);
    s->c4 = SET(state_vec[4], state_vec[9], state_vec[14], state_vec[19]);
    s->a44 = _mm256_set1_epi64x(state_vec[24]);

}


size_t fastLoop (void *state, unsigned int rate, const uint8_t * data, size_t length){
    CONSTANTS 
    PERMUTE_VARS
    const uint64_t* data64;
    ptrdiff_t currentDataBytePosition;
    STATE_LOAD
    for (currentDataBytePosition = 0; currentDataBytePosition <= (ptrdiff_t) (length/8 - rate/8); currentDataBytePosition += (length/8 - rate/8)){
        data64 = (uint64_t*) (data + currentDataBytePosition);
        switch (rate)
        {
        
        case 72:
            a0 = XOR(a0, LOAD(data64));
            a1 = XOR(a1, LOAD(data64 + 5));
            c4 = XOR(c4, MASKLOAD(data64+4, 1 ,0, 0, 0));
        break;
        case 104:
            a0 = XOR(a0, LOAD(data64));
            a1 = XOR(a1, LOAD(data64 + 5));
            a2 = XOR(a2, MASKLOAD(data64 + 10, 1, 1, 1,0));
            c4 = XOR(c4, SET(data64+4, data64 + 9 ,0, 0));
        break;
        case 136:
            a0 = XOR(a0, LOAD(data64));
            a1 = XOR(a1, LOAD(data64 + 5));
            a2 = XOR(a2, LOAD(data64 + 10));
            a3 = XOR(a3, MASKLOAD(data64 + 15, 1, 1, 0, 0));
            c4 = XOR(c4, SET(data64+4, data64 + 9 ,data64 + 14, 0));
        break;
        case 144:
            a0 = XOR(a0, LOAD(data64));
            a1 = XOR(a1, LOAD(data64 + 5));
            a2 = XOR(a2, LOAD(data64 + 10));
            a3 = XOR(a3, MASKLOAD(data64 + 15, 1, 1, 1, 0));
            c4 = XOR(c4, SET(data64+4, data64 + 9 ,data64 + 14, 0));
        break;
        case 168:
            a0 = XOR(a0, LOAD(data64));
            a1 = XOR(a1, LOAD(data64 + 5));
            a2 = XOR(a2, LOAD(data64 + 10));
            a3 = XOR(a3, LOAD(data64 + 15));
            a4 = XOR(a4, MASKLOAD(data64 + 20, 1, 0, 0, 0));
            c4 = XOR(c4, SET(data64+4, data64 + 9 ,data64 + 14, data64 + 19));
        break;
        default:
            STATE_STORE
            addBytes(state, (uint8_t*) data64, 0, length - rate);
            STATE_LOAD
        }
        STATE_PERMUTE(_)
    }
    STATE_STORE
    return currentDataBytePosition * 8;


}  