
//576 SHA3512
//832 SHA3384
//1024 ??
//1088 SHAKE256, SHA3256
//1152 SHA3224
//1344 SHAKE128
//1600 ??



#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <immintrin.h>
#include <stdlib.h>
#include <stdio.h>

#ifdef __ALIGN
#undef __ALIGN
#endif

#if defined(_GNUC_)
#define __ALIGN(x) _attribute_ ((aligned(x)))
#elif defined(_MSC_VER)
#define __ALIGN(x) __declspec(align(x))
#elif defined(__ARMCC_VERSION)
#define __ALIGN(x) __align(x)
#else
#define __ALIGN(x)
#endif



typedef struct keccak_state_t {
    __m256i a0, a1, a2, a3, a4, c4, a44;
} keccak_state_t;

typedef uint64_t keccak_rc_t[4]; 

// Reverse order.
__ALIGN(32) keccak_rc_t keccak_rc[24] =
{
    {0x8000000080008008ull},    //round 23
    {0x0000000080000001ull},
    {0x8000000000008080ull},
    {0x8000000080008081ull},
    {0x800000008000000Aull},
    {0x000000000000800Aull},
    {0x8000000000000080ull},
    {0x8000000000008002ull},
    {0x8000000000008003ull},
    {0x8000000000008089ull},
    {0x800000000000008Bull},
    {0x000000008000808Bull},
    {0x000000008000000Aull},
    {0x0000000080008009ull},
    {0x0000000000000088ull},
    {0x000000000000008Aull},
    {0x8000000000008009ull},
    {0x8000000080008081ull},
    {0x0000000080000001ull},
    {0x000000000000808Bull},
    {0x8000000080008000ull},
    {0x800000000000808Aull},
    {0x0000000000008082ull},
    {0x0000000000000001ull}, //roundÂ 0
};


#define XOR(a, b) _mm256_xor_si256(a, b)
#define SET(i0, i1, i2, i3) _mm256_setr_epi64x(i0, i1, i2, i3)
#define MASKLOAD(p, i0, i1, i2, i3) _mm256_maskload_epi64((const int64_t*) p, SET((uint64_t) (i0)  << 63, (uint64_t) (i1) << 63, (uint64_t) (i2) << 63, (uint64_t) (i3) << 63))

#define CONSTANTS \
__m256i SLLVA0 = _mm256_setr_epi64x(0,  1, 62, 28);\
__m256i SRLVA0 = _mm256_setr_epi64x(64, 63, 2, 36);\
__m256i SLLVA2 = _mm256_setr_epi64x(3,  10, 43, 25);\
__m256i SRLVA2 = _mm256_setr_epi64x(61, 54, 21, 39);\
__m256i SLLVA1 = _mm256_setr_epi64x(36,  44, 6, 55);\
__m256i SRLVA1 = _mm256_setr_epi64x(28, 20, 58, 9);\
__m256i SLLVA3 = _mm256_setr_epi64x(41,  45, 15, 21);\
__m256i SRLVA3 = _mm256_setr_epi64x(23, 19, 49, 43);\
__m256i SLLVA4 = _mm256_setr_epi64x(18,  2, 61, 56);\
__m256i SRLVA4 = _mm256_setr_epi64x(46, 62, 3, 8);\
__m256i SLLVC4 = _mm256_setr_epi64x(27,  20, 39, 8);\
__m256i SRLVC4 = _mm256_setr_epi64x(37, 44, 25, 56);\
\
__m256i SLLV_A0 = _mm256_setr_epi64x(0,  1, 62, 28);\
__m256i SRLV_A0 = _mm256_setr_epi64x(64, 63, 2, 36);\
__m256i SLLV_A2 = _mm256_setr_epi64x(3,  10, 43, 25);\
__m256i SRLV_A2 = _mm256_setr_epi64x(61, 54, 21, 39);\
__m256i SLLV_A1 = _mm256_setr_epi64x(36,  44, 6, 55);\
__m256i SRLV_A1 = _mm256_setr_epi64x(28, 20, 58, 9);\
__m256i SLLV_A3 = _mm256_setr_epi64x(41,  45, 15, 21);\
__m256i SRLV_A3 = _mm256_setr_epi64x(23, 19, 49, 43);\
__m256i SLLV_A4 = _mm256_setr_epi64x(18,  2, 61, 56);\
__m256i SRLV_A4 = _mm256_setr_epi64x(46, 62, 3, 8);\
__m256i SLLV_C4 = _mm256_setr_epi64x(27,  20, 39, 8);\
__m256i SRLV_C4 = _mm256_setr_epi64x(37, 44, 25, 56);

#define PERMUTE_VARS\
    __m256i a0, a1, a2, a3, a4, c4;\
    __m256i a04, a14, a24, a34, a44;\
    __m256i b0, b1, b2, b3, b4;\
    __m256i b04, b14, b24, b34, b44;\
    __m256i r0, r1, r2, r3;\
    keccak_state_t* s = (keccak_state_t*) state;\
    ptrdiff_t iterator;


#define LOAD(p)\
    _mm256_loadu_si256((__m256i*) p)

#define STORE(p, a)\
    _mm256_storeu_si256((__m256i*) p, a)


#define STATE_LOAD\
    a0 = LOAD(&(s->a0));\
    a1 = LOAD(&(s->a1));\
    a2 = LOAD(&(s->a2));\
    a3 = LOAD(&(s->a3));\
    a4 = LOAD(&(s->a4));\
    c4 = LOAD(&(s->c4));\
    a44 = LOAD(&(s->a44));

#define STATE_STORE\
    STORE(&s->a0, a0);\
    STORE(&s->a1, a1);\
    STORE(&s->a2, a2);\
    STORE(&s->a3, a3);\
    STORE(&s->a4, a4);\
    STORE(&s->c4, c4);\
    STORE(&s->a44, a44);

#define BLEND(a, b, i0, i1, i2, i3) _mm256_blend_epi32(a, b, _MM_SHUFFLE(3*i3, 3*i2, 3*i1, 3*i0))
#define ROL(a, i) XOR(_mm256_slli_epi64(a, i), _mm256_srli_epi64(a, 64 - i))

#define PERMUTE(a, i0, i1, i2 ,i3)\
    _mm256_permute4x64_epi64(a, _MM_SHUFFLE(i3, i2, i1 ,i0))

#define ROLV(a, name)\
    XOR(_mm256_sllv_epi64(a, SLLV##name),_mm256_sllv_epi64(a, SRLV##name))


#define PERMUTE_LOOP(const_pref, nofRounds)\
    for (iterator = (nofRounds-1); iterator >= 0; iterator--){\
        r0 = XOR(a0, a1);\
        r0 = XOR(r0, a2);\
        r0 = XOR(r0, a3);\
        r0 = XOR(r0, a4);\
        r1 = XOR(c4, _mm256_permute2x128_si256(c4, c4, 0x11));\
        r1 = XOR(r1,_mm256_unpackhi_epi64(r1, r1));\
        r1 = XOR(r1, a44);\
        b0 = PERMUTE(r0, 3, 0, 1, 2);\
        b04 = b0;\
        b0 = BLEND(b0, r1, 1, 0, 0, 0);\
        r0 = ROL(r0, 1);\
        r1 = ROL(r1, 1);\
        r1 = BLEND(r0, r1, 1, 0, 0, 0);\
        r1 = PERMUTE(r1, 1, 2, 3, 0);\
        b0 = XOR(b0, r1);\
        b04 = XOR(b04, r0);\
        a0 = XOR(a0, b0);\
        a1 = XOR(a1, b0);\
        a2 = XOR(a2, b0);\
        a3 = XOR(a3, b0);\
        a4 = XOR(a4, b0);\
        a44 = XOR(a44, b04);\
        c4 = XOR(c4, _mm256_broadcastq_epi64(_mm256_castsi256_si128(b04)));\
        b0 = ROLV(a0, const_pref##A0);\
        b1 = ROLV(a1, const_pref##A1);\
        b2 = ROLV(a2, const_pref##A2);\
        b3 = ROLV(a3, const_pref##A3);\
        b4 = ROLV(a4, const_pref##A4);\
        c4 = ROLV(c4, const_pref##C4);\
        a44 = ROL(a44, 14);\
        r0 = PERMUTE(b0, 0, 3, 1, 0);\
        r1 = _mm256_broadcastq_epi64(_mm256_castsi256_si128(c4));\
        b04 = _mm256_permute2x128_si256(b0, b0, 0x11);\
        b0 = BLEND(r0, r1, 0, 0, 0, 1);\
        r0 = PERMUTE(b1, 1, 3, 2, 0);\
        r1 = _mm256_unpackhi_epi64(c4, c4);\
        b14 = PERMUTE(b1, 3, 3, 3, 3);\
        b1 = BLEND(r0, r1, 0, 1, 0, 0);\
        b2 = PERMUTE(b2, 2, 0, 3, 1);\
        b24 =  _mm256_permute2x128_si256(c4, c4, 0x11);\
        r0 = PERMUTE(b3, 3, 1, 0, 2);\
        r1 = PERMUTE(c4, 3, 3, 3, 3);\
        b34 = b3;\
        b3 = BLEND(r0, r1, 0, 0, 1, 0);\
        r0 = PERMUTE(b4, 1, 2, 0, 3);\
        r1 = _mm256_broadcastq_epi64(_mm256_castsi256_si128(a44));\
        b44 = _mm256_unpackhi_epi64(b4, b4);\
        b4 = BLEND(r0, r1, 1, 0, 0, 0);\
        a0 = XOR(b0, _mm256_andnot_si256(b1, b2)); \
        a0 = XOR(a0, *(__m256i *)(keccak_rc + iterator)); \
        a1 = XOR(b1, _mm256_andnot_si256(b2, b3)); \
        a2 = XOR(b2, _mm256_andnot_si256(b3, b4)); \
        a3 = XOR(b3, _mm256_andnot_si256(b4, b0)); \
        c4 = XOR(b4, _mm256_andnot_si256(b0, b1)); \
        r0 = _mm256_unpacklo_epi64(a0, a1); \
        r1 = _mm256_unpackhi_epi64(a0, a1); \
        r2 = _mm256_unpacklo_epi64(a2, a3); \
        r3 = _mm256_unpackhi_epi64(a2, a3); \
        a0 = _mm256_permute2x128_si256(r0, r2, 0x20); \
        a1 = _mm256_permute2x128_si256(r1, r3, 0x20); \
        a2 = _mm256_permute2x128_si256(r2, r0, 0x13); \
        a3 = _mm256_permute2x128_si256(r3, r1, 0x13); \
        a04 = XOR(b04, _mm256_andnot_si256(b14, b24)); \
        a14 = XOR(b14, _mm256_andnot_si256(b24, b34)); \
        a24 = XOR(b24, _mm256_andnot_si256(b34, b44)); \
        a34 = XOR(b34, _mm256_andnot_si256(b44, b04)); \
        a44 = XOR(b44, _mm256_andnot_si256(b04, b14)); \
        r0 = _mm256_unpacklo_epi64(a04, a14); \
        r1 = _mm256_unpacklo_epi64(a24, a34); \
        a4 = _mm256_permute2x128_si256(r0, r1, 0x20);\
        \
    }

#define STATE_PERMUTE(const_pref) \
    PERMUTE_LOOP(const_pref, 24);




void extractBytes(const void* state, uint8_t* data, size_t offset, size_t length) {
    keccak_state_t* s = (keccak_state_t*) state;
    uint64_t state_vec[25];
    uint64_t *data64 = (!offset && (length >= 200)) ? (uint64_t*) data : state_vec;
    uint64_t* c4 = (uint64_t*) (&s->c4);
    if  (data64 == state_vec && length > 200){
        length = 200;
    }
    STORE(data64, s->a0);
    STORE(data64 + 5, s->a1);
    STORE(data64 + 10, s->a2);
    STORE(data64 + 15, s->a3);
    STORE(data64 + 20, s->a4);
    data64[4] = c4[0];
    data64[9] = c4[1];
    data64[14] = c4[2];
    data64[19] = c4[3];
    data64[24] = c4[4];
    if (data64 == state_vec)
    {
        memcpy(data, (uint8_t*) state_vec + offset, length);
    }

}



void addBytes(void *state, const uint8_t* data, size_t offsetof, size_t length){
    keccak_state_t* s = (keccak_state_t*) state;
    uint64_t* data64 = (uint64_t*) data;
    uint8_t * currentStateBytePosition, *currentDataBytePosition;
    uint64_t state_vec[25];
    uint64_t* base_state_byte_position;
    ptrdiff_t currentWindow = length / 8;
    volatile ptrdiff_t currentByte = length % 8;
    printf(" calculating current byte: %d\n", currentByte);
    ptrdiff_t i;
    printf("  extracting\n");
    extractBytes(state, (uint8_t*) state_vec, 0, 200);
    printf("  extracted\n");
    base_state_byte_position = (uint64_t*) ((uint8_t*) state_vec + offsetof);
    printf("  base base done\n");
    for (i = 0; i < currentWindow; i++) {
        printf(" %d %d\n", *data, *((uint64_t*)data));
        printf(" %d\n", *data64);
        printf("  %d'th iteration\n Data is %d", i, data64[i]);
        printf("  %d\n", base_state_byte_position[i]);
        base_state_byte_position[i] ^= data64[i];
    }
    printf("  base done\n");
    if (currentByte) {
        currentStateBytePosition = (uint8_t*) (base_state_byte_position+i);
        currentDataBytePosition = (uint8_t*) (data64 + i);
        printf(" positions done\n");
        printf(" %d %llu\n", currentByte, (uint64_t) currentByte);
        for (i = 0; i < currentByte; i++){
            printf(" %d %d %d %d\n", currentByte, i, currentStateBytePosition[i], currentDataBytePosition[i]);
            currentStateBytePosition[i] ^= currentDataBytePosition[i];
        }
    }
    printf("  loading\n");

    s->a0 = LOAD(state_vec);
    s->a1 = LOAD(state_vec + 5);
    s->a2 = LOAD(state_vec + 10);
    s->a3 = LOAD(state_vec + 15);
    s->a4 = LOAD(state_vec + 20);
    s->c4 = SET(state_vec[4], state_vec[9], state_vec[14], state_vec[19]);
    s->a44 = _mm256_set1_epi64x(state_vec[24]);
    printf("  loaded\n");
}


size_t fastLoop (void *state, unsigned int rate, const uint8_t * data, size_t length){
    CONSTANTS 
    PERMUTE_VARS
    const uint64_t* data64;
    ptrdiff_t currentDataBytePosition;
    STATE_LOAD
    for (currentDataBytePosition = 0; currentDataBytePosition <= (ptrdiff_t) (length/8 - rate/8); currentDataBytePosition += (length/8 - rate/8)){
        data64 = (uint64_t*) (data + currentDataBytePosition);
        switch (rate)
        {
        
        case 72:
            a0 = XOR(a0, LOAD(data64));
            a1 = XOR(a1, LOAD(data64 + 5));
            c4 = XOR(c4, MASKLOAD(data64+4, 1 ,0, 0, 0));
        break;
        case 104:
            a0 = XOR(a0, LOAD(data64));
            a1 = XOR(a1, LOAD(data64 + 5));
            a2 = XOR(a2, MASKLOAD(data64 + 10, 1, 1, 1,0));
            c4 = XOR(c4, SET(data64+4, data64 + 9 ,0, 0));
        break;
        case 136:
            a0 = XOR(a0, LOAD(data64));
            a1 = XOR(a1, LOAD(data64 + 5));
            a2 = XOR(a2, LOAD(data64 + 10));
            a3 = XOR(a3, MASKLOAD(data64 + 15, 1, 1, 0, 0));
            c4 = XOR(c4, SET(data64+4, data64 + 9 ,data64 + 14, 0));
        break;
        case 144:
            a0 = XOR(a0, LOAD(data64));
            a1 = XOR(a1, LOAD(data64 + 5));
            a2 = XOR(a2, LOAD(data64 + 10));
            a3 = XOR(a3, MASKLOAD(data64 + 15, 1, 1, 1, 0));
            c4 = XOR(c4, SET(data64+4, data64 + 9 ,data64 + 14, 0));
        break;
        case 168:
            a0 = XOR(a0, LOAD(data64));
            a1 = XOR(a1, LOAD(data64 + 5));
            a2 = XOR(a2, LOAD(data64 + 10));
            a3 = XOR(a3, LOAD(data64 + 15));
            a4 = XOR(a4, MASKLOAD(data64 + 20, 1, 0, 0, 0));
            c4 = XOR(c4, SET(data64+4, data64 + 9 ,data64 + 14, data64 + 19));
        break;
        default:
            STATE_STORE
            addBytes(state, (uint8_t*) data64, 0, length - rate);
            STATE_LOAD
        }
        STATE_PERMUTE(_)
    }
    STATE_STORE
    return currentDataBytePosition * 8;
}  

void permute24rounds(void* state) {
    CONSTANTS
    PERMUTE_VARS
    STATE_LOAD
    STATE_PERMUTE()
    STATE_STORE

}

void addByte(void* state, uint8_t byte, size_t offset){
    uint8_t byte1[1];
    byte1[0] = byte;
    addBytes(state, byte1, offset, 1);
}